### Введение и Глава 1: Что такое дизайн и архитектура
Мартин говорит что дизайн и архитектура это одно и то же по сути. Нет смысла их разделять - это просто решения разного уровня, от мелких до крупных. Как в строительстве дома - есть общий план и есть детали про розетки, но все это один дизайн дома.

Главная цель архитектуры - сделать так чтобы люди тратили меньше сил на создание и поддержку системы. Если со временем каждое изменение дается все труднее, значит архитектура плохая. Если система остается гибкой, архитектура хорошая.

Мартин приводит реальный пример компании где команда выросла с 1 до 8 разработчиков, а продуктивность упала почти до нуля, потому что код превратился в кашу. Стоимость строки кода выросла в 40 раз. Все из-за того что думали "потом наведем порядок", но потом никогда не приходило.

Основное правило - поспешай не торопясь. Чистый код всегда быстрее грязного, даже если кажется что грязным можно быстрее выйти на рынок.

### Глава 2: История о двух ценностях
У любой программы есть две ценности. Первая - поведение, то есть что программа делает. Вторая - структура, то есть насколько легко программу менять.

Большинство программистов зацикливаются на поведении и забывают про структуру. Но это неправильно. Программа которая работает но ее нельзя изменить, станет бесполезной когда изменятся требования. А программу которую можно легко изменить, всегда можно заставить работать правильно.

Мартин использует матрицу Эйзенхауэра - есть срочное и важное. Поведение программы срочное но не всегда важное. Архитектура важная но не всегда срочная. Люди путают срочное с важным и в итоге игнорируют архитектуру.

Разработчики должны бороться за архитектуру так же как менеджеры борются за свои интересы. Если архитектуру игнорировать, потом будет очень дорого что-то менять.

### Глава 3: Обзор парадигм
Есть три парадигмы программирования и больше не будет. Все они были придуманы между 1958 и 1968 годами.

Структурное программирование убрало goto и дало нам if/then/else и циклы. Объектно-ориентированное дало полиморфизм через указатели на функции, только безопасный. Функциональное ограничило присваивание.

Интересно что все парадигмы что-то отнимают у программиста, а не добавляют. Они накладывают ограничения чтобы упростить программы.

Эти парадигмы важны для архитектуры. Полиморфизм помогает преодолевать границы, функциональное программирование ограничивает данные, структурное дает основу для модулей.

### Глава 4: Структурное программирование
Дейкстра в 1960х заметил что goto вредит структуре программы и мешает доказывать ее правильность. Он предложил заменить goto на структурированные конструкции.

Бём и Якопини доказали что любую программу можно написать используя только последовательность, выбор и итерации. Получается что структуры которые делают программу доказуемой, это как раз минимальный набор нужный для любой программы.

Формальные доказательства правильности программ так и не прижились, но программирование стало больше похоже на науку. Мы не можем доказать что программа правильная, но можем доказать что она неправильная с помощью тестов.

Структурное программирование дает возможность создавать модули которые можно тестировать. Это его главная ценность для архитектуры.

### Глава 5: Объектно-ориентированное программирование
Мартин разбирает три "магических" слова ООП - инкапсуляцию, наследование и полиморфизм.

Инкапсуляция в ООП языках на самом деле слабее чем была в C. В C можно было спрятать структуру в .c файле, а в C++ все переменные видны в заголовке.

Наследование тоже существовало и до ООП, просто в виде трюков с указателями. ООП просто сделало это удобнее.

А вот полиморфизм - это действительно главное что дает ООП. Указатели на функции существовали всегда, но были опасными. ООП сделало полиморфизм безопасным и удобным.

Главная сила полиморфизма - инверсия зависимостей. Теперь архитектор может контролировать направление всех зависимостей в коде. Можно сделать так что база данных и пользовательский интерфейс зависят от бизнес-правил, а не наоборот.

Это позволяет делать компоненты сменными как плагины, разрабатывать и разворачивать их независимо. В этом суть ООП для архитектора.

### Глава 6: Функциональное программирование
В этой главе Мартин описывает функциональную парадигму как третью основную (после структурной и объектно-ориентированной). Ключевой принцип — неизменяемость данных: переменные не меняют своё значение после инициализации. Это устраняет проблемы с состоянием, особенно в многопоточных системах (нет гонок данных, блокировок). Функции должны быть чистыми — без побочных эффектов, зависящими только от входных параметров.

Функциональное программирование повышает устойчивость архитектуры к изменениям, но требует компромиссов (например, transactional memory для mutable частей). Event sourcing — пример: храним события (транзакции), а не состояние, и вычисляем его на лету для аудита или экономии памяти.

Пример на C# (императивный vs функциональный подход):
Императивный код (с mutable переменными):

```
csharp
class ImperativeExample
{
    public static void Main()
    {
        int[] numbers = {1, 2, 3, 4, 5};
        int sum = 0;
        for (int i = 0; i < numbers.Length; i++)
        {
            sum += numbers[i] * numbers[i]; // Мутация sum
        }
        Console.WriteLine("Сумма квадратов: " + sum);
    }
}
```

Функциональный подход (используем LINQ, immutable коллекции):

```
csharp
using System.Collections.Immutable;
using System.Linq;

class FunctionalExample
{
    public static void Main()
    {
        var numbers = ImmutableList.Create(1, 2, 3, 4, 5); // Immutable коллекция
        var sumOfSquares = numbers.Select(x => x * x).Sum(); // Чистая функция, без мутаций
        Console.WriteLine("Сумма квадратов: " + sumOfSquares);
    }
}
```

Здесь в функциональном варианте нет мутаций, всё вычисляется на лету. В большом проекте это упрощает отладку и параллелизм.

### Глава 7: Принцип единственной ответственности (SRP)
SRP гласит: модуль (класс) должен иметь одну и только одну причину для изменения, то есть отвечать перед одним "актором" (группой заинтересованных лиц). Это не значит "делать одну вещь" (это для функций), а о разделении по ответственности. Нарушение SRP приводит к непреднамеренному дублированию кода или конфликтам при слиянии (merge conflicts), когда изменения для одного актора ломают код для другого.

Пример нарушения: класс Employee с методами calculatePay (для бухгалтерии), reportHours (для HR) и save (для админов БД). Изменение calculatePay может сломать reportHours.

Решение: разделить на классы EmployeePayroll, EmployeeHours и EmployeePersistence, или использовать фасады для группировки.

Пример на C# (нарушение SRP):

```
csharp
class EmployeeBad
{
    public decimal CalculatePay() { /* Логика для бухгалтерии */ return 0; }
    public int ReportHours() { /* Логика для HR */ return 0; }
    public void Save() { /* Логика для БД */ }
}
```

Исправленный вариант (с фасадом):

```
csharp
class EmployeePayroll { public decimal CalculatePay() { return 0; } }
class EmployeeHours { public int ReportHours() { return 0; } }
class EmployeePersistence { public void Save() { } }

class EmployeeFacade // Фасад для объединения
{
    private EmployeePayroll payroll = new EmployeePayroll();
    private EmployeeHours hours = new EmployeeHours();
    private EmployeePersistence persistence = new EmployeePersistence();

    public decimal CalculatePay() { return payroll.CalculatePay(); }
    public int ReportHours() { return hours.ReportHours(); }
    public void Save() { persistence.Save(); }
}
```

Теперь изменения в payroll не затрагивают hours. Это отражает закон Конвея: структура кода повторяет структуру команды.

### Глава 8: Принцип открытости/закрытости (OCP)
OCP: модуль должен быть открыт для расширения (добавления нового поведения), но закрыт для модификации (изменения существующего кода). Достигается через абстракции и полиморфизм: низкоуровневые детали зависят от высокоуровневых абстракций.

Пример: финансовый отчёт. Без OCP добавление принтерного вывода меняет весь код. С OCP — используем интерфейсы и наследование.

Управление зависимостями: в UML стрелки должны указывать на абстрактные элементы. Это "сокрытие информации" — изменения не расползаются.

Пример на C# (без OCP):

```
csharp
class FinancialReport
{
    public void Generate() { /* Генерация отчета на экран */ Console.WriteLine("Report"); }
}
```

Добавление принтерного вывода требует изменения Generate().

С OCP:

```
csharp
abstract class ReportGenerator
{
    public abstract void Generate(); // Закрыт для модификации, открыт для расширения
}

class ScreenReport : ReportGenerator
{
    public override void Generate() { Console.WriteLine("Screen Report"); }
}

class PrinterReport : ReportGenerator
{
    public override void Generate() { Console.WriteLine("Printer Report"); }
}
```

### Глава 9: Принцип подстановки Лисков (LSP)
LSP: подтипы должны быть взаимозаменяемыми с базовыми типами без изменения поведения программы. Классика — квадрат/прямоугольник: квадрат наследует прямоугольник, но изменение ширины/высоты независимо ломает квадрат (нарушение ожиданий).

В архитектуре: если сервисы не взаимозаменяемы (разные REST API), код пачкается if-ами. Решение: строгие контракты.

Пример на C# (нарушение LSP):

```
csharp
class Rectangle
{
    public virtual int Width { get; set; }
    public virtual int Height { get; set; }
    public int Area() { return Width * Height; }
}

class Square : Rectangle // Квадрат наследует прямоугольник
{
    public override int Width { set { base.Width = value; base.Height = value; } } // Ломает независимость
    public override int Height { set { base.Width = value; base.Height = value; } }
}

class Test
{
    public static void Main()
    {
        Rectangle r = new Square();
        r.Width = 5; r.Height = 10; // Ожидаем Area=50, но для квадрата Area=100
        Console.WriteLine(r.Area()); // Нарушение
    }
}
```

Решение: не наследовать квадрат от прямоугольника, использовать отдельный класс. В микросервисах LSP критично для совместимых API.

### Глава 10: Принцип разделения интерфейсов (ISP)
ISP: не завись от того, что не используешь. Интерфейсы должны быть мелкими, чтобы клиенты не зависели от ненужных методов. Изменение в неиспользуемом методе не должно требовать перекомпиляции.

В статических языках (C#) это спасает от рекомпиляций. Связан с DIP, но для интерфейсов.

Пример на C# (нарушение ISP):

```
csharp
interface UserService
{
    void AddUser(); // Используется
    void DeleteUser(); // Не используется
    void UpdateUser(); // Не используется
    // Ещё 7 методов, которые не нужны
}

class MyClient
{
    private UserService service; // Зависит от всего, даже неиспользуемого
    public void Add() { service.AddUser(); }
}
```

Решение: разбить на мелкие интерфейсы:

```
csharp
interface IAddUserService { void AddUser(); }
interface IDeleteUserService { void DeleteUser(); }

class MyClient : IAddUserService // Только нужное
{
    public void AddUser() { /* Реализация */ }
}
```

В больших системах ISP предотвращает "ненужные" рекомпиляции.

В целом, SOLID — основа для масштабируемых систем. В проекте на C# я бы применил OCP для расширений, SRP для разделения зон ответственности. Теперь всё понятнее, надо внедрять в код.
### Введение и Глава 1: Что такое дизайн и архитектура
Мартин говорит что дизайн и архитектура это одно и то же по сути. Нет смысла их разделять - это просто решения разного уровня, от мелких до крупных. Как в строительстве дома - есть общий план и есть детали про розетки, но все это один дизайн дома.

Главная цель архитектуры - сделать так чтобы люди тратили меньше сил на создание и поддержку системы. Если со временем каждое изменение дается все труднее, значит архитектура плохая. Если система остается гибкой, архитектура хорошая.

Мартин приводит реальный пример компании где команда выросла с 1 до 8 разработчиков, а продуктивность упала почти до нуля, потому что код превратился в кашу. Стоимость строки кода выросла в 40 раз. Все из-за того что думали "потом наведем порядок", но потом никогда не приходило.

Основное правило - поспешай не торопясь. Чистый код всегда быстрее грязного, даже если кажется что грязным можно быстрее выйти на рынок.

### Глава 2: История о двух ценностях
У любой программы есть две ценности. Первая - поведение, то есть что программа делает. Вторая - структура, то есть насколько легко программу менять.

Большинство программистов зацикливаются на поведении и забывают про структуру. Но это неправильно. Программа которая работает но ее нельзя изменить, станет бесполезной когда изменятся требования. А программу которую можно легко изменить, всегда можно заставить работать правильно.

Мартин использует матрицу Эйзенхауэра - есть срочное и важное. Поведение программы срочное но не всегда важное. Архитектура важная но не всегда срочная. Люди путают срочное с важным и в итоге игнорируют архитектуру.

Разработчики должны бороться за архитектуру так же как менеджеры борются за свои интересы. Если архитектуру игнорировать, потом будет очень дорого что-то менять.

### Глава 3: Обзор парадигм
Есть три парадигмы программирования и больше не будет. Все они были придуманы между 1958 и 1968 годами.

Структурное программирование убрало goto и дало нам if/then/else и циклы. Объектно-ориентированное дало полиморфизм через указатели на функции, только безопасный. Функциональное ограничило присваивание.

Интересно что все парадигмы что-то отнимают у программиста, а не добавляют. Они накладывают ограничения чтобы упростить программы.

Эти парадигмы важны для архитектуры. Полиморфизм помогает преодолевать границы, функциональное программирование ограничивает данные, структурное дает основу для модулей.

### Глава 4: Структурное программирование
Дейкстра в 1960х заметил что goto вредит структуре программы и мешает доказывать ее правильность. Он предложил заменить goto на структурированные конструкции.

Бём и Якопини доказали что любую программу можно написать используя только последовательность, выбор и итерации. Получается что структуры которые делают программу доказуемой, это как раз минимальный набор нужный для любой программы.

Формальные доказательства правильности программ так и не прижились, но программирование стало больше похоже на науку. Мы не можем доказать что программа правильная, но можем доказать что она неправильная с помощью тестов.

Структурное программирование дает возможность создавать модули которые можно тестировать. Это его главная ценность для архитектуры.

### Глава 5: Объектно-ориентированное программирование
Мартин разбирает три "магических" слова ООП - инкапсуляцию, наследование и полиморфизм.

Инкапсуляция в ООП языках на самом деле слабее чем была в C. В C можно было спрятать структуру в .c файле, а в C++ все переменные видны в заголовке.

Наследование тоже существовало и до ООП, просто в виде трюков с указателями. ООП просто сделало это удобнее.

А вот полиморфизм - это действительно главное что дает ООП. Указатели на функции существовали всегда, но были опасными. ООП сделало полиморфизм безопасным и удобным.

Главная сила полиморфизма - инверсия зависимостей. Теперь архитектор может контролировать направление всех зависимостей в коде. Можно сделать так что база данных и пользовательский интерфейс зависят от бизнес-правил, а не наоборот.

Это позволяет делать компоненты сменными как плагины, разрабатывать и разворачивать их независимо. В этом суть ООП для архитектора.

